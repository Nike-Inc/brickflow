import importlib
import json
import os
import re
import sys
from pathlib import Path
from typing import Dict

import click
from jinja2 import Environment, BaseLoader

from brickflow import _ilog

PWD = Path(__file__).parent.absolute()
GITIGNORE_TEMPLATE = PWD / "gitignore_template.txt"
GIT_PATH = Path(".git")


class GitNotFoundError(Exception):
    pass


class GitIgnoreNotFoundError(Exception):
    pass


def _gitignore_exists() -> bool:
    return os.path.exists(".gitignore") and os.path.isfile(".gitignore")


def _create_gitignore_if_not_exists() -> None:
    if _gitignore_exists() is False:
        Path(".gitignore").touch(mode=0o755)


def _get_gitignore() -> str:
    return Path(".gitignore").read_text(encoding="utf-8")


def _get_gitignore_template() -> str:
    return GITIGNORE_TEMPLATE.read_text()


def _write_gitignore(data: str) -> None:
    Path(".gitignore").write_text(encoding="utf-8", data=data)


def _update_gitignore() -> None:
    search_regex = re.compile(
        r"(# GENERATED BY BRICKFLOW CLI --START--(.|\n)*# GENERATED BY BRICKFLOW CLI --END--)"
    )

    git_ignore_data = _get_gitignore()
    git_ignore_template = _get_gitignore_template()
    search = search_regex.findall(git_ignore_data)
    if len(search) > 0:
        search_match = search[0][0]
        gitignore_file_data = git_ignore_data.replace(search_match, git_ignore_template)
    else:
        gitignore_file_data = "\n\n".join([git_ignore_data, git_ignore_template])
    _write_gitignore(gitignore_file_data)


def _validate_package(path_str: str) -> str:
    folder_path: Path = Path(path_str)

    if not folder_path.exists():
        raise ImportError(f"Invalid pkg error: {folder_path.as_posix()}")

    sys.path.append(os.getcwd())
    folder_pkg_path: str = folder_path.as_posix().replace("/", ".")

    for module in folder_path.glob("**/*.py"):  # only find python files
        # ignore __init__.py
        if module.name == "__init__.py":
            continue
        module_name = module.as_posix().replace(".py", "").replace("/", ".")
        # import all the modules into the mod object and not actually import them using __import__
        mod = importlib.import_module(module_name)
        click.echo(f"Scanned module: {mod.__name__}")

    return folder_pkg_path


def render_template(**kwargs) -> str:  # type: ignore
    template = Path(__file__).parent.absolute() / "entrypoint.template"
    with template.open("r") as f:
        data = f.read()
        return Environment(loader=BaseLoader()).from_string(data).render(**kwargs)


def create_entry_point(working_dir: str, data: str) -> None:
    path = Path(working_dir) / "entrypoint.py"
    if path.exists():
        click.echo(f"Path: {str(path.absolute())} already exists...")
        # path = Path(working_dir) / "entrypoint.py.new"
    else:
        click.echo(f"Creating file in path: {str(path.absolute())}...")
        path.write_text(data)


def _build_cdktf_json(working_dir: str) -> Dict[str, str]:
    content = {}
    new_entrypoint_app = f"BRICKFLOW_MODE=deploy python {working_dir}/entrypoint.py"
    content["app"] = new_entrypoint_app
    content["language"] = "python"
    return content


def _write_cdktf_json(content: Dict[str, str]) -> None:
    _ilog.info("Setting up the cdktf.json file for the execution")
    Path("cdktf.json").write_text(json.dumps(content, indent=4), encoding="utf-8")


def idempotent_cdktf_out(working_dir: str) -> None:
    # cdktf_dict = _get_cdktf_dict() if _cdktf_json_exists() is True else {}
    content = _build_cdktf_json(working_dir)
    _write_cdktf_json(content)
